#define _CRT_SECURE_NO_WARNINGS
#include "Network.h"
#include "Key.h"
#include "..\ChatCrypto\AES.h"
#include "../ChatCrypto/RSA.h"
#include <cstring>
#include <openssl/applink.c>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <iostream>

unsigned char serverPublicKey[460] = {
   0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50,
   0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D,
   0x2D, 0x2D, 0x0D, 0x0A, 0x4D, 0x49, 0x49, 0x42, 0x49, 0x6A, 0x41, 0x4E,
   0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42,
   0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x4F, 0x43, 0x41, 0x51, 0x38, 0x41,
   0x4D, 0x49, 0x49, 0x42, 0x43, 0x67, 0x4B, 0x43, 0x41, 0x51, 0x45, 0x41,
   0x74, 0x38, 0x43, 0x62, 0x5A, 0x32, 0x54, 0x76, 0x6E, 0x78, 0x52, 0x43,
   0x68, 0x48, 0x50, 0x74, 0x6F, 0x37, 0x38, 0x74, 0x0D, 0x0A, 0x42, 0x2F,
   0x2B, 0x79, 0x73, 0x76, 0x49, 0x46, 0x70, 0x37, 0x42, 0x62, 0x53, 0x42,
   0x68, 0x64, 0x52, 0x6F, 0x6B, 0x44, 0x51, 0x35, 0x59, 0x4E, 0x75, 0x74,
   0x33, 0x37, 0x2B, 0x52, 0x65, 0x54, 0x79, 0x39, 0x7A, 0x48, 0x6A, 0x59,
   0x50, 0x38, 0x72, 0x59, 0x4E, 0x6E, 0x75, 0x66, 0x52, 0x73, 0x4D, 0x2F,
   0x46, 0x44, 0x6B, 0x42, 0x50, 0x62, 0x59, 0x78, 0x72, 0x59, 0x65, 0x6B,
   0x6E, 0x31, 0x0D, 0x0A, 0x78, 0x54, 0x71, 0x35, 0x5A, 0x73, 0x62, 0x2B,
   0x37, 0x37, 0x45, 0x76, 0x42, 0x71, 0x38, 0x47, 0x4F, 0x79, 0x65, 0x76,
   0x77, 0x32, 0x51, 0x34, 0x4A, 0x79, 0x4F, 0x68, 0x69, 0x67, 0x6C, 0x71,
   0x74, 0x67, 0x6B, 0x70, 0x50, 0x42, 0x68, 0x49, 0x46, 0x44, 0x4B, 0x6E,
   0x4C, 0x57, 0x4D, 0x59, 0x47, 0x2B, 0x68, 0x53, 0x59, 0x39, 0x64, 0x44,
   0x46, 0x63, 0x71, 0x47, 0x4F, 0x36, 0x73, 0x73, 0x0D, 0x0A, 0x2F, 0x72,
   0x30, 0x50, 0x73, 0x66, 0x35, 0x43, 0x32, 0x63, 0x4A, 0x37, 0x54, 0x63,
   0x6C, 0x50, 0x2F, 0x34, 0x69, 0x65, 0x54, 0x52, 0x63, 0x67, 0x46, 0x53,
   0x46, 0x38, 0x5A, 0x47, 0x66, 0x76, 0x47, 0x4C, 0x50, 0x76, 0x62, 0x6B,
   0x69, 0x67, 0x47, 0x70, 0x30, 0x55, 0x70, 0x6E, 0x5A, 0x57, 0x51, 0x2F,
   0x4D, 0x5A, 0x65, 0x30, 0x76, 0x4F, 0x39, 0x50, 0x37, 0x78, 0x63, 0x6B,
   0x62, 0x79, 0x0D, 0x0A, 0x69, 0x43, 0x71, 0x6C, 0x70, 0x52, 0x43, 0x5A,
   0x31, 0x63, 0x58, 0x37, 0x32, 0x44, 0x44, 0x7A, 0x4C, 0x30, 0x41, 0x4A,
   0x69, 0x56, 0x46, 0x73, 0x79, 0x70, 0x6D, 0x6B, 0x35, 0x38, 0x66, 0x58,
   0x75, 0x4C, 0x55, 0x39, 0x4E, 0x73, 0x6D, 0x4E, 0x47, 0x61, 0x33, 0x34,
   0x50, 0x43, 0x7A, 0x4E, 0x53, 0x49, 0x2F, 0x4A, 0x6E, 0x6D, 0x2F, 0x35,
   0x4E, 0x6F, 0x68, 0x69, 0x79, 0x49, 0x6A, 0x31, 0x0D, 0x0A, 0x44, 0x39,
   0x30, 0x69, 0x46, 0x50, 0x76, 0x55, 0x30, 0x6B, 0x6D, 0x44, 0x4A, 0x59,
   0x49, 0x55, 0x69, 0x36, 0x39, 0x45, 0x58, 0x65, 0x61, 0x76, 0x6F, 0x46,
   0x71, 0x53, 0x51, 0x34, 0x35, 0x75, 0x6C, 0x35, 0x6E, 0x4F, 0x47, 0x4D,
   0x6B, 0x66, 0x61, 0x55, 0x31, 0x53, 0x47, 0x48, 0x45, 0x68, 0x6D, 0x41,
   0x73, 0x31, 0x45, 0x6E, 0x42, 0x76, 0x63, 0x61, 0x2B, 0x49, 0x33, 0x4E,
   0x59, 0x72, 0x0D, 0x0A, 0x2F, 0x77, 0x49, 0x44, 0x41, 0x51, 0x41, 0x42,
   0x0D, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x50,
   0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D,
   0x2D, 0x2D, 0x0D, 0x0A
};


void Network::Close()
{
    if (false == IsConnected())
        return;

    struct linger stLinger = { 0, 0 };
    shutdown(SessionSocket, SD_BOTH);
    setsockopt(SessionSocket, SOL_SOCKET, SO_LINGER, (char*)&stLinger, sizeof(stLinger));
    closesocket(SessionSocket);
}

void Network::CreatePublicKey()
{
    std::string publicKeyPEM = rsa.exportPublicKeyPEM();
    PublicKey.assign(publicKeyPEM.begin(), publicKeyPEM.end());
}

void Network::CreatePrivateKey()
{
    std::string privateKeyPEM = rsa.exportPrivateKeyPEM();
    PrivateKey.assign(privateKeyPEM.begin(), privateKeyPEM.end());
}

void Network::CreateSymmetricKey()
{
    AESWrapper aes;
    AESKey = aes.generateKey();
}

void Network::CreateIV()
{
    AESWrapper aes;
    AESIV = aes.generateIV();
}

int Network::recv(WSABUF wsabuf)
{
    DWORD dwFlag = 0;
    DWORD dwRecvNumBytes = 0;

    return WSARecv(SessionSocket, &wsabuf, 1, &dwRecvNumBytes, &dwFlag, (LPWSAOVERLAPPED)&IOData[IO_RECV], NULL);
}


bool Network::BindRecv()
{
    int nRet = this->recv(IOData[IO_RECV].WsaBuf());

    if (nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING))
    {
        printf("[RECV_SOCKET_ERROR] Client Connection Terminated\n");
        Close();
        return false;
    }

    return true;
}


bool Network::SendPacket(std::vector<BYTE> data, PacketType pType)
{
    // IOCP 워커 쓰레드에서 메모리 할당 해제시킴
    AESWrapper aes;
    std::vector<BYTE> encData = aes.encryptWithAES(data, AESKey, AESIV);
    WSABUF wsabuf = IOData[IO_SEND].SetData(pType, encData.data(), encData.size());
    DWORD dwSentNumBytes = 0;
    int nRet = WSASend(SessionSocket, &wsabuf, 1, &dwSentNumBytes, 0, (LPWSAOVERLAPPED)&IOData[IO_SEND], NULL);

    printf("[sentByte] %d bytes sent\n", dwSentNumBytes);

    if (nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING))
    {
        printf("[ERROR] client Send Error\n");
        return false;
    }

    return true;
}

int Network::send(WSABUF wsabuf)
{
    DWORD dwSentNumBytes = 0;

    return WSASend(SessionSocket, &wsabuf, 1, &dwSentNumBytes, 0, (LPWSAOVERLAPPED)&IOData[IO_SEND], NULL);
}

void Network::ParsePacket()
{
    std::vector<BYTE> data = PacketBuilder::GetPacketData();
    std::vector<BYTE> response;
    PacketType ptype = PacketBuilder::GetPacketType();

    if (data.size() == 0 || data[0] == 0x00)
    {
        printf("Parse fail\n");
        return;
    }

    Key key;

    switch (ptype)
    {
    case SERVER_SEND_OPPONENT_PUBLIC_KEY:
    {
        // Guest로부터 공개키 받음
        std::vector<BYTE> publicKey;
        std::copy(data.begin() + 1, data.begin() + 1 + RSA_KEY_SIZE, publicKey.begin());

        key.StorePublicKey(publicKey);
        break;
    }

    case SERVER_SEND_ROOM_SYMMETRICKEY:
    {
        // Room 대칭키 받음
        std::vector<BYTE> symmetricKey;
        std::copy(data.begin() + 1, data.begin() + 1 + AES_KEY_SIZE, symmetricKey.begin());

        key.StoreAESKey(symmetricKey);
        break;
    }

    case SERVER_ROOM_LIST:
    {
        std::string roomname;
        RoomList.clear(); // 기존 RoomList를 초기화

        for (size_t i = 0; i < data.size(); ++i)
        {
            if (data[i] == '\0')
            {
                if (!roomname.empty())
                {
                    // Room name is complete, add to RoomList
                    RoomList.insert(RoomList.end(), roomname.begin(), roomname.end());
                    roomname.clear(); // Prepare for the next room name
                }
            }
            else
            {
                roomname += static_cast<char>(data[i]); // Append character to roomname
            }
        }

        // 마지막 roomname 추가
        if (!roomname.empty())
        {
            RoomList.insert(RoomList.end(), roomname.begin(), roomname.end());
        }

        break;
    }
    }
}

// serverPublicKey를 EVP_PKEY로 변환하는 함수
EVP_PKEY* convertToEVP_PKEY(const unsigned char* keyData, size_t keyLen)
{
    // BIO 메모리 버퍼 생성
    BIO* bio = BIO_new_mem_buf(keyData, keyLen);
    if (!bio) {
        std::cerr << "Failed to create BIO\n";
        return nullptr;
    }

    // PEM 형식의 공개 키를 EVP_PKEY 구조체로 변환
    EVP_PKEY* publicKey = PEM_read_bio_PUBKEY(bio, nullptr, nullptr, nullptr);
    BIO_free(bio); // BIO 자원 해제

    if (!publicKey) {
        std::cerr << "Failed to convert PEM to EVP_PKEY\n";
        ERR_print_errors_fp(stderr); // OpenSSL 오류 출력
    }

    return publicKey;
}

bool Network::SendSymmetricKey()
{
    // IOCP 워커 쓰레드에서 메모리 할당 해제시킴
    RSAEncryption rsa1;

    EVP_PKEY* evpPkey = convertToEVP_PKEY(serverPublicKey, sizeof(serverPublicKey));
    std::vector<BYTE> encData = rsa1.encryptWithPublicKey(AESKey, evpPkey);
    WSABUF wsabuf = IOData[IO_SEND].SetData(CLIENT_SEND_PUBLICKEY, encData.data(), encData.size());
    DWORD dwSentNumBytes = 0;
    int nRet = WSASend(SessionSocket, &wsabuf, 1, &dwSentNumBytes, 0, (LPWSAOVERLAPPED)&IOData[IO_SEND], NULL);

    printf("[sentByte] %d bytes sent\n", dwSentNumBytes);

    if (nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING))
    {
        printf("[ERROR] client Send Error\n");
        return false;
    }

    return true;
}

bool Network::SendPublicKey()
{
    std::cout<<SendPacket(AESKey, CLIENT_SEND_SYMMETRICKEY);
    return true;
}


void Network::PrintPrivateKey()
{
    std::cout << "Private Key: ";
    for (const BYTE& byte : PrivateKey)
    {
        std::cout << static_cast<char>(byte);
    }
    std::cout << std::endl;
}

void Network::PrintPublicKey()
{
    std::cout << "Private Key: ";
    for (const BYTE& byte : PublicKey)
    {
        std::cout << static_cast<char>(byte);
    }
    std::cout << std::endl;
}
